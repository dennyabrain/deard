var CommentForm = require('./commentform')
var CommentList = require('./commentList')
var Loader = require('./loader')

module.exports = React.createClass({
	displayName: 'Content',

	contextTypes : {
		userKey : React.PropTypes.any,
		setUserKey : React.PropTypes.func,
		history : React.PropTypes.object	
	},
	getCommentsFromServer: function() {
		$.ajax({
			url: this.props.url,
			dataType: 'json',
			cache: false,
			success: function(data){
				this.context.setUserKey(data.userKey)
				this.setState({loadingResponse: false, loaded: true, data:data.comments}, function() {
        				// Update the commentFormType on latest bot response.
					var revComments = (this.state.data.comments || []).reverse();
					for (var c in revComments) {
						if (c.type == 'bot') {
							if (c.commentFormType) {
								if (this.state.commentFormType != c.commentFormType) {
									this.setState({commentFormType : c.commentFormType});
								}
							}							
							break;
						}
					}
				});
			}.bind(this),
			error: function(ehx, status, err) {
				console.log(this.props.url, status, err.toString());
				this.context.history.pushState(null, "/", {});
			}.bind(this)
		});
	},
	handleCommentSubmit: function(comment) {
		var comments = this.state.data;
		// Optimistically set an id on the new comment. It will be replaced by an
		// id generated by the server. In a production application you would likely
		// not use Date.now() for this and would have a more robust system in place.

		// comments.type, comments.text 

		comment.id = Date.now();
		// comment.author = this.context.userKey;
		comment.type = "user";
		var newComments = comments.concat([comment]);

		this.setState({data: newComments, loadingResponse: true});
		this.disablePolling();

		$.ajax({
			url: this.props.url,
			dataType: 'json',
			type: 'POST',
			data: comment,
			success: function(data){

				// In order to "fake" the loading, disable comment polling until we're done
				// Wait 3 seconds, and then get new comments from server and re-enable polling.
				setTimeout(function() {
					this.setState({loadingResponse: false}, function() {
						this.getCommentsFromServer();
						this.enablePolling();
					});
				}.bind(this), 3000);
			}.bind(this),
			error: function(ehx, status, err) {
				console.log(this.props.url, status, err.toString());
			}.bind(this)
		});
	},
	getInitialState: function() {
		return {data:[], loaded: false, commentFormType: "mood"};
	}, 
	getDefaultProps : function() { 
		return {url:"/comments", pollInterval: 3000}; 
	},
	componentDidMount: function() {
		setTimeout(function() {
			this.getCommentsFromServer();
			this.enablePolling();
		}.bind(this), 2000);
	},
	componentWillUnmount: function() {
		this.disablePolling();
	},
	enablePolling: function() {
		this.checkInterval = setInterval(this.getCommentsFromServer, this.props.pollInterval);
	},
	disablePolling: function() {
		clearInterval(this.checkInterval);
	},
	render: function() {
		return (
			<div className="content main">
				{ this.state.loaded ? 
					(<CommentList data={this.state.data} loading={this.state.loadingResponse}/>) :
					(<Loader />)
				}
				<div className="commentFormArea">
					<div className="container">
						<CommentForm commentFormType={this.state.commentFormType} onCommentSubmit={this.handleCommentSubmit} />
					</div>
				</div>
			</div>
		)
	}
});